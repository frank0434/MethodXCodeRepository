---
title: "Data_acquisition"
author: "jian (AKA Frank) liu"
date: "04/10/2019"
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_depth: 3
---

# ReadMe

**This is the notebook to import the data from K/I/whatever the driver is and send raw/cleaned data to a postgresql DB on powerplant.**

**Plan:**

1. Read data in
2. Select down to right soil water measurments
3. Send the raw data from each measurment to DB - this is for examing the suprise values 
4. Clean out missing and stupid high values   _Yet to be done_
5. Average the value in each layer (7 layers in total for rainshelter; 4 layers for the stony lysimeter)
6. Calculate deficit 
7. Upload the calculated deficit to DB - for real irrigation scheduling - need to be a separate table 

**PostgreSQL credentials**

    host = "database.powerplant.pfr.co.nz",
    database = "cflfcl_MPI_SVS",
    user = "cflfcl_SVS",
    password = "vVsYDCzw7PD4Phb1"
    
**Format that `sqlalchemy` like**
    
    "postgresql://cflfcl_SVS:vVsYDCzw7PD4Phb1@database.powerplant.pfr.co.nz/cflfcl_MPI_SVS"
    
**Demo data source**

    
**Outcomes**

### libraries


```{r setup, include=FALSE,warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
source("packages.R")
```

### DataSource

```{r}
url = "https://iplant.plantandfood.co.nz/project/I190710/DataProtocols/SVS_PotatoOnion_SoilWater.xlsx"

sheet = "SoilWaterMainData"
GET(url, authenticate(Sys.getenv("USERNAME"), Sys.getenv("PASSWORD"),
                       type = "ntlm"), 
    write_disk(tf <- tempfile(fileext = ".xlsx"), overwrite = TRUE)) 
list.files(tf)
df = read_excel(tf, sheet, skip = 9,) %>% 
  as.data.table()
colnames(df)
```


```{python}
import datetime
import pandas as pd
import numpy as np
import time 
import psycopg2
from sqlalchemy import create_engine
import os
import streaming_tool as st
import matplotlib.pyplot as plt
```

# Tidy up the RAW VWC

Two user define functions:
1. one to combine the index and raw sensor data 
2. two to rename the variable names for database 

```{python}
NewData = st.merge_index(AllData = AllData, AllDataIndex = AllDataIndex)
db_ready = st.cat_column(NewData)
NewData
db_ready

```

```{python}
import json
json.dumps(list(db_ready.columns))
```

```{python}
# a bit checking by plot 
db_ready.plot(figsize = (10,8), legend = False)
plt.show()
```

##### Establish the connection with DB

```{python}
engine = create_engine("postgresql://cflfcl_Rainshelter_SWC:o654UkI6iGNwhzHu@database.powerplant.pfr.co.nz/cflfcl_Rainshelter_SWC")
```

```{python}
# UPLOAD TO DB
db_ready.to_sql(name="RoundedRaw_Pea", con=engine,if_exists='replace' )
```

# Figure out faulty sensors

1. Assign `1` to replace the NAs or unreal number of data
2. Save the sensors ID for the calculation later 

```{python}
# figure out which sensor is faulty before run aggregation
# not dropping any sensors since we want to notice the faulty ones.
# replace the non sense values with 1
# make the fanny sensor yield 1
faulty_sensors = st.detect_faulty(NewData)
np.save('Faulty_sensors.npy', faulty_sensors)
faulty_sensors = np.load('Faulty_sensors.npy', allow_pickle=True)   

# checking if the faulty sensors have been removed.
# Yes if there is no line at the value of 1 or 0
NewData.drop(columns=list(faulty_sensors)).plot(figsize = (10,8), legend = False)
```

# Mean VWC by Plot

```{python}
# last filter to get ready upload the raw 
# is not actually calculate any mean, just want to see the data
vwc_plot = NewData.droplevel(['Cultivar', 'Irrigation','Sensor'], axis=1)

vwc_plot.filter(regex = '215')
vwc_plot.head(5)

```


```{python}
stacked = vwc_plot.stack().reset_index()
stacked
# import matplotlib.pyplot as plt 
# num = 0
# for i in range(201, 225):
#     num+=1
#     plt.subplot(12, 2, num)
#     i = str(i)
#     stacked.loc[stacked.Plot == i, 'level_0':'D7'].plot(x = df['level_0'])
#     plt.title('Plot' + i) 
```

# SUMMARISING

Old copy from the previous set up.

```{python}
LastRow = NewData.index.size

np.save('LastRow_Pea.npy',LastRow)
LastRead = np.load('LastRow_Pea.npy')
LastRow
```

```{python}
DataMeans = NewData.drop(columns = list(faulty_sensors)).groupby(level=['Depth','Irrigation', 'Cultivar'],axis=1).mean()
DataMeans = DataMeans.dropna(axis=1) #For some reason it keeps non valid combinations in so need to extract with this function
# DataMeans = DataMeans.resample('4H').last() # 4 hours subsetting

#Calculate the water content of the soil profile by multiplying the volumetric water content by each layers
#depth and summing. 

ProfileWater = DataMeans.loc[:,'D1I'] * 150/2 + \
               DataMeans.loc[:,'D1B'] * 150/2 + \
               DataMeans.loc[:,'D2'] * 150 + \
               DataMeans.loc[:,'D3'] * 300 + \
               DataMeans.loc[:,'D4'] * 300 + \
               DataMeans.loc[:,'D5'] * 300 + \
               DataMeans.loc[:,'D6'] * 300 + \
               DataMeans.loc[:,'D7'] * 300
# extract the stone and gravel description for renaming
L1 = ProfileWater.columns.get_level_values(0)
L2 = ProfileWater.columns.get_level_values(1)

# rename the columns
ProfileWater.columns = L1 + '_' + L2

# use the starting date as field capacity - the next two lines only need to run once 
# FieldCapacity = ProfileWater.resample('D').last().loc['2019-11-19', :] 
# FieldCapacity.to_pickle('FieldCapacity_Pea.pkl')

FieldCapacity_Pea = pd.read_pickle('FieldCapacity_Pea.pkl') 
SoilWaterDeficit = -(FieldCapacity_Pea- ProfileWater)
```

```{python}
ProfileWater
# SoilWaterDeficit
```

```{python}
FieldCapacity_Pea
# SoilWaterDeficit
# ProfileWater
```

# Upload an initial data set into the DB

only need to run once for each set up 

```{python}
SoilWaterDeficit.to_sql(name="SoilWaterDeficit_Pea",con=engine,if_exists='replace' ) # will over write db
ProfileWater.to_sql(name="ProfileWater_Pea",con=engine,if_exists='replace' ) # will over write db
```


```{python}
# upload data to db
stacked.to_sql(name="RoundedRaw_Pea_Plot",con=engine,if_exists='replace' ) # will over write the existing db
```

## A bit plotting for checking

```{python}
ProfileWater.dropna().plot(figsize=(18,10),style=['r--','b--','g--','r-','b-','g-'], linewidth=4)
plt.ylabel('ProfileWater (mm)', fontsize=36);
plt.tick_params(labelsize=25)
plt.title('Rainshelter SWD', fontsize=28);
plt.legend(fontsize=24, loc=4)
plt.show()
```

```{python}
SoilWaterDeficit
```

**Plot shows nothing**
probably too many NAs


```{python}
DailyProfile = ProfileWater.resample('D').mean()
DailyProfile.index.name = 'Date'
SoilWaterDeficit.plot(figsize=(18,10), style=['r--','b--','g--','r-','b-','g-'],linewidth=4)
plt.tick_params(labelsize=25)
plt.title('Rainshelter Profile Water', fontsize=28);
plt.legend(fontsize=24, loc=3)
plt.show()
```
## Problems





